# Interactive JSONL Explorer Fullstack Architecture Document

<!-- This document is generated by Winston, the Architect AI, based on the fullstack-architecture-tmpl.yaml template. -->

## 1. Introduction

This document outlines the complete technical architecture for the **Interactive JSONL Explorer**. It serves as the single source of truth for development, ensuring that the project adheres to its core technical principles: a vanilla JavaScript, single-file HTML application with no runtime frameworks. The architecture is designed to deliver a high-performance, intuitive, and secure client-side tool for developers and product managers.

This document covers the application's structure, data handling, component design, build process, and performance strategies, providing a comprehensive blueprint for implementation.

### 1.1. Starter Template or Existing Project

N/A - This is a greenfield project with no existing codebase or starter template. The architecture is being designed from the ground up based on the specific requirements in the PRD.

### 1.2. Change Log

| Date       | Version | Description              | Author   |
| :--------- | :------ | :----------------------- | :------- |
| 2024-07-30 | 1.0     | Initial Architecture     | Winston  |

## 2. High-Level Architecture

### 2.1. Technical Summary

The Interactive JSONL Explorer is a client-side monolith, packaged as a single, self-contained HTML file. It is built with vanilla JavaScript (ES6+), HTML5, and CSS3, with no external runtime frameworks or libraries. The architecture prioritizes performance, using Web Workers for non-blocking file parsing and a virtualized DOM for rendering large result sets efficiently. All data processing, filtering, and rendering occur exclusively in the user's browser, ensuring data privacy and eliminating the need for a backend server. A lightweight build tool, Vite, will be used during development to bundle all assets into the final distributable HTML file.

### 2.2. Platform and Infrastructure Choice

The application is designed for pure client-side execution and requires no traditional backend infrastructure.

*   **Platform:** Static Web Hosting
*   **Key Services:** None required. The application can be served from any static host.
*   **Deployment Host and Regions:** Any static hosting provider such as GitHub Pages, Vercel, Netlify, or even opened directly from the local filesystem (`file:///`).

### 2.3. Repository Structure

As specified in the PRD, the project will use a monorepo structure. While it's a single application, this approach keeps the codebase organized and accommodates the build process and future testing suites cleanly.

*   **Structure:** Monorepo
*   **Monorepo Tool:** npm workspaces will be sufficient for managing development dependencies.
*   **Package Organization:** A `src` directory will contain all the application source code, logically separated into modules (components, services, utils). A `dist` directory will hold the final bundled `index.html`.

### 2.4. High-Level Architecture Diagram
```mermaid
graph TD
    subgraph Browser
        A[User] -->|Uploads JSONL file(s)| B(UI);
        B --> C{File Handler};
        C -->|Sends file to worker| D[Parser Web Worker];
        D -->|Streams parsed objects| E[In-Memory Data Store];
        B -->|Builds query| F{Query Engine};
        F -->|Filters data from| E;
        E -->|Provides filtered results| G[Results View];
        G -->|Displays formatted JSON| B;
    end

    subgraph Build Process
        H[src/*.js] --> J{Vite};
        I[src/*.css] --> J;
        K[index.html template] --> J;
        J --> L[dist/index.html];
    end

    style B fill:#2b4052,stroke:#fff,stroke-width:2px;
    style G fill:#2b4052,stroke:#fff,stroke-width:2px;
    style D fill:#4a6e8b,stroke:#fff,stroke-width:2px;
    style E fill:#c26a3a,stroke:#fff,stroke-width:2px;
```

### 2.5. Architectural Patterns

*   **Component-Based UI (Vanilla):** The UI will be constructed from independent, reusable components (e.g., `QueryBuilder`, `ResultsList`), each managing its own state and DOM representation. This will be implemented in vanilla JavaScript without a framework.
*   **Observer (Pub/Sub):** A simple, global event emitter will be used for state management. Components can subscribe to events (e.g., `data:loaded`, `filter:updated`) and react to state changes without being tightly coupled.
*   **Web Workers for Off-Thread Parsing:** To prevent the UI from freezing while processing large files, file parsing will be delegated to a separate Web Worker thread. This is the cornerstone of the application's performance strategy.
*   **Virtual DOM / DOM Diffing (Manual):** To render large lists of results performantly, a virtual scrolling technique will be used. Only the visible items in the results list will be rendered to the DOM, dramatically reducing the number of nodes and improving responsiveness.

## 3. Tech Stack

This table represents the definitive technology selection for the project. All development must adhere to these choices.

| Category             | Technology         | Version | Purpose                                             | Rationale                                                                        |
| :------------------- | :----------------- | :------ | :-------------------------------------------------- | :------------------------------------------------------------------------------- |
| Frontend Language    | JavaScript (ES6+)  | ES2020+ | Core application logic                              | Meets the "vanilla JS" requirement. Modern features improve code quality.        |
| Markup Language      | HTML5              | 5       | Application structure                               | Standard for modern web applications.                                            |
| Styling              | CSS3               | 3       | UI styling and layout                               | Meets the "vanilla CSS" requirement. Flexbox, Grid, and media queries will be used for a fully responsive layout. |
| Build Tool           | Vite               | Latest  | Development server, bundling, and inlining          | Provides a fast dev experience and a simple configuration for the single-file build. |
| Frontend Testing     | Vitest             | Latest  | Unit and integration testing                        | Native to the Vite ecosystem, fast, and has a Jest-compatible API.                 |
| E2E Testing          | Playwright         | Latest  | End-to-end testing of user flows                    | Provides reliable cross-browser testing for the complete application.            |
| Code Formatting      | Prettier           | Latest  | Consistent code style                               | Enforces a uniform style guide, improving readability.                           |
| Linting              | ESLint             | Latest  | Code quality and error prevention                   | Catches common errors and enforces best practices.                               |

## 4. Data Models

The primary data structure is the JSON object parsed from the user's files, augmented with metadata.

### `LogEntry`

**Purpose:** Represents a single parsed JSON object from a JSONL file, with added metadata for tracking its origin.

**Key Attributes:**
- `id`: `string` - A unique identifier assigned to the entry for rendering purposes.
- `sourceFile`: `string` - The name of the file this object was parsed from.
- `data`: `object` - The original JSON object parsed from the file line.

#### Data Structure

```javascript
/**
 * Represents a single log entry.
 * @typedef {object} LogEntry
 * @property {string} id - A unique identifier for the entry.
 * @property {string} sourceFile - The name of the file the entry came from.
 * @property {object} data - The parsed JSON object.
 */
```

## 5. API Specification

Not applicable. The application is entirely client-side, with no backend API.

## 6. Components

The application will be broken down into several logical, DOM-manipulating components.

*   **`App`**
    *   **Responsibility:** The main container component that initializes all other components and orchestrates the overall application flow.
    *   **Dependencies:** `FileUpload`, `SchemaExplorer`, `QueryBuilder`, `ResultsView`, `StateService`

*   **`FileUpload`**
    *   **Responsibility:** Handles the user interface and logic for file selection, including the file picker and drag-and-drop functionality. Publishes an event with the loaded files.
    *   **Dependencies:** `StateService`

*   **`SchemaExplorer`**
    *   **Responsibility:** Receives the parsed data, discovers all unique (including nested) keys, and renders them in a hierarchical, collapsible tree view.
    *   **Dependencies:** `StateService`

*   **`QueryBuilder`**
    *   **Responsibility:** Provides the UI for creating filter rules and groups (AND/OR). It uses the discovered schema for key selection and publishes the constructed query object.
    *   **Dependencies:** `StateService`

*   **`ResultsView`**
    *   **Responsibility:** The most complex component. It listens for new query results, renders them using a virtual scrolling mechanism, and provides aesthetically pleasing JSON formatting with collapsible sections.
    *   **Dependencies:** `StateService`

*   **`FileParserService` (Web Worker)**
    *   **Responsibility:** Runs in a separate thread. Responsible for receiving file handles, reading them line-by-line, parsing JSON, and streaming `LogEntry` objects back to the main thread.
    *   **Dependencies:** None

*   **`StateService` (Pub/Sub Module)**
    *   **Responsibility:** A simple event bus for managing application state. It holds the master list of log entries, the discovered schema, and the current filter query. Components subscribe to it for updates.
    *   **Dependencies:** None

## 7. Unified Project Structure

The project will be organized to separate source code from build artifacts, promoting a clean and maintainable structure.

```plaintext
interactive-jsonl-explorer/
├── .vscode/                 # VSCode settings
├── dist/                    # Build output directory
│   └── index.html           # The final, single-file application
├── public/                  # Static assets (if any, like a favicon)
├── src/                     # Application source code
│   ├── components/          # UI component modules
│   │   ├── QueryBuilder.js
│   │   ├── ResultsView.js
│   │   └── ...
│   ├── services/            # Core logic modules
│   │   ├── stateService.js  # Pub/Sub state manager
│   │   └── queryEngine.js   # Filtering logic
│   ├── workers/             # Web Worker scripts
│   │   └── parser.worker.js
│   ├── styles/              # CSS files
│   │   └── main.css
│   ├── utils/               # Helper functions
│   │   └── dom.js
│   └── main.js              # Main application entry point
├── index.html               # The HTML template for the build
├── package.json
├── vite.config.js           # Vite build configuration
└── README.md
```

## 8. Performance Strategy

Client-side performance is the most critical non-functional requirement. The strategy is twofold:

1.  **Non-Blocking Parsing with Web Workers:**
    *   File reading and JSON parsing are the most CPU-intensive tasks. By moving this work to a Web Worker, the main UI thread remains responsive, allowing the user to interact with the application even while large files (100MB+) are being processed.
    *   The worker will stream parsed objects back to the main thread incrementally, allowing the UI to update the total count without waiting for the entire file to be processed.

2.  **Efficient Rendering with Virtual Scrolling:**
    *   Rendering a large number of DOM nodes (e.g., 10,000+ log entries) is the primary cause of UI sluggishness. A virtual scrolling implementation for the `ResultsView` will be created.
    *   This technique calculates which log entries are currently in the viewport and renders only those DOM nodes. As the user scrolls, nodes that move out of view are removed or recycled, and new nodes are rendered just in time. This keeps the DOM size small and ensures a smooth scrolling experience regardless of the total number of results.

## 9. Testing Strategy

The testing strategy will follow the "Testing Pyramid" model to ensure confidence and maintainability.

*   **Unit Tests (Vitest):**
    *   These will form the base of the pyramid and cover individual functions and modules in isolation.
    *   **Targets:** Query engine logic, schema discovery algorithm, utility functions.

*   **Integration Tests (Vitest + DOM simulation):**
    *   These will test the interaction between modules. For example, verifying that when the `QueryBuilder` updates a filter, the `ResultsView` receives the filtered data from the `StateService` and renders it correctly.

*   **End-to-End Tests (Playwright):**
    *   These tests will simulate full user journeys in a real browser.
    *   **Example Flow:**
        1.  Launch the application.
        2.  Programmatically upload a test `.jsonl` file.
        3.  Verify that file names and schema appear.
        4.  Build a query using the UI controls.
        5.  Assert that the results view updates and contains the correct, filtered entries.

This tiered approach provides a robust safety net, catching bugs at the lowest possible level while validating the complete user experience.

## 12. Coding Standards

To ensure code consistency, readability, and maintainability, the project will adhere to the following standards.

*   **Code Formatting:** All JavaScript and CSS code will be automatically formatted using **Prettier** upon saving. The specific rules are defined in the project's `.prettierrc` configuration file. This enforces a single, consistent style guide.

*   **Code Quality:** **ESLint** will be used to statically analyze the code and identify potential problems. The ruleset, defined in `.eslintrc.js`, will be based on the recommended standards for modern JavaScript.

*   **Naming Conventions:**
    *   **JavaScript Modules/Files:** `camelCase.js` (e.g., `queryEngine.js`).
    *   **JavaScript Classes/Components:** `PascalCase.js` (e.g., `ResultsView.js`).
    *   **CSS Classes:** `kebab-case` (e.g., `.query-builder`).
    *   **Variables & Functions:** `camelCase` (e.g., `const logEntries = ...`).

*   **Documentation:** All but the most trivial functions should be documented using **JSDoc** comments to describe their purpose, parameters, and return values.

## 11. Error Handling Strategy

The application will handle errors gracefully to prevent crashes and provide clear feedback to the user.

*   **File Parsing Errors:** The `FileParserService` (Web Worker) will wrap the `JSON.parse()` call in a `try...catch` block for each line.
    *   If a line fails to parse, the worker will not terminate. Instead, it will increment an error counter and post a message to the main thread containing the source filename, line number, and error message.
    *   Malformed lines will be ignored and excluded from the data set.

*   **User Interface Feedback:**
    *   The main UI will listen for these error messages from the parser.
    *   A dedicated and clearly visible status area within the "Files & Schema" sidebar will explicitly report all file parsing errors to the end-user.
    *   This status area will display a clear summary of the issues (e.g., "File `logs.jsonl`: Skipped 3 malformed lines."). The user will be able to click this summary to view more details about the specific line numbers and errors.
    *   The developer console will still contain detailed logs of each parsing error for debugging purposes.

This approach ensures the application remains robust and responsive, even with imperfect data, a core requirement from the PRD.

## 10. Accessibility (A11y) Strategy

The application will adhere to Web Content Accessibility Guidelines (WCAG) 2.1 Level AA standards, as required by the PRD. Accessibility is a primary consideration and will be integrated throughout the development lifecycle.

*   **Semantic HTML:** Components will be constructed using semantic HTML5 elements (`<nav>`, `<main>`, `<button>`, `<input>`, etc.) to ensure a meaningful and navigable structure for assistive technologies. Non-semantic elements (`div`, `span`) will be reserved for styling purposes.

*   **ARIA Roles & Attributes:** Where the semantics of dynamic components cannot be fully conveyed by native HTML, appropriate ARIA (Accessible Rich Internet Applications) roles and attributes will be used. This includes `role="status"` for announcing updates, `aria-live` regions for dynamic content, and attributes like `aria-label` for clarifying control purposes.

*   **Keyboard Navigation:** All interactive elements—including file upload controls, query builder inputs, buttons, and result entries—will be fully operable via the keyboard. A logical and predictable focus order will be maintained throughout the application.

*   **Focus Management:** Clear and visible focus indicators will be present on all focusable elements. For UI components that appear and disappear, such as modals or dropdowns, focus will be managed programmatically to ensure a seamless experience for keyboard users.

*   **Color Contrast:** The "Operator Dark" theme will be implemented with color combinations that meet or exceed the WCAG AA contrast ratio of 4.5:1 for all text and UI components.

*   **Testing Strategy:**
    *   **Automated:** An accessibility testing library (e.g., `axe-core`) will be integrated into the Playwright E2E test suite to automatically catch common violations during testing.
    *   **Manual:** Regular manual testing will be performed using keyboard-only navigation and screen readers (e.g., NVDA, VoiceOver) to ensure a high-quality, usable experience for all users.
